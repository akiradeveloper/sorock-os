<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sorock</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="architecture.html">Architecture</a></li><li class="chapter-item expanded affix "><a href="api.html">API</a></li><li class="chapter-item expanded affix "><a href="math.html">Math</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">Sorock</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>After knowing about the concept of \( \infty \),
everyone has once used to get addicted to it.</p>
<p>So, scale-out distributed storage is a man's dream.
The performance and the capacity will be infinitely
scaled up by adding more servers to the cluster.</p>
<p>However, in practice, it is not easy to implement a
infinitely scaling out distributed storage when 
node failures should be considered.</p>
<p>The goal of this project <strong>Sorock</strong> is to implement 
a fully automatic perfect scale-out distributed storage
that will never lose data in more than eleven nines SLA level.</p>
<p>The modernest Rust language is chosen to build a quality software.</p>
<h1><a class="header" href="#architecture" id="architecture">Architecture</a></h1>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>Sorock implements the server using <a href="https://github.com/hyperium/tonic">Tonic</a> so
all external communication is done by gRPC.</p>
<p>Tonic allows to stack gRPC services in the server.</p>
<p>Sorock uses Raft consensus algorithm to replicate the cluster change
because all nodes have to at least eventually see the same cluster state and replication should be quick enough.
Some other system uses gossip protocol to disseminate the cluster change but using Raft it will be more quicker.</p>
<p>Raft service builds the <a href="https://github.com/akiradeveloper/ASURA">ASURA</a> data structure based on cluster changes and then it is passed to Storage service.</p>
<p>Storage service is responsible for handling user requests but lot of p2p communications are executed in the cluster.
When the cluster is changed, it tries to move the erasure-coded pieces to the appropriate nodes and rebuild a piece if it is lost.</p>
<p><img src="images/arch.png" alt="" /></p>
<h2><a class="header" href="#microservices" id="microservices">Microservices</a></h2>
<p>The internal of the Storage service is implemented as a group of in-process microservices.</p>
<p><a href="https://github.com/akiradeveloper/norpc">norpc</a> is a library to design async application that in-process microservices running on Tokio runtime communicate each other using RPC over messsage channel. You can learn more about the library in this doc: <a href="https://akiradeveloper.github.io/norpc/">norpc book</a>.</p>
<p>This project is not only a aspiring distributed storage project but an experiment in software architecture. My question is &quot;Can norpc design async application better?&quot;. To search for the answer, the internal of Sorock is designed this way.</p>
<p><img src="images/microservices.png" alt="" /></p>
<h1><a class="header" href="#api" id="api">API</a></h1>
<p>Sorock provides only simple APIs.</p>
<h2><a class="header" href="#createkey-value" id="createkey-value">Create(Key, Value)</a></h2>
<p>Create a key-value pair in the storage.
Key shouldn't be reused for any two different values.
Typically, the key is generated from the value using hash function like SHA1.</p>
<h2><a class="header" href="#readkey" id="readkey">Read(Key)</a></h2>
<p>Read the value from the storage.</p>
<h2><a class="header" href="#deletekey" id="deletekey">Delete(Key)</a></h2>
<p>Delete the key-value pair.</p>
<h2><a class="header" href="#addnodeuri-capacity" id="addnodeuri-capacity">AddNode(URI, Capacity)</a></h2>
<p>Add a node in the cluster.
Regarding the Capacity, recommendation is setting x if the node has xTB local storage.</p>
<h2><a class="header" href="#removenodeuri" id="removenodeuri">RemoveNode(URI)</a></h2>
<p>Remove a node from the cluster.</p>
<h1><a class="header" href="#math" id="math">Math</a></h1>
<p>We can give a theoretical analysis to Sorock
by doing some maths.</p>
<h2><a class="header" href="#how-many-pieces-are-moved-on-cluster-change" id="how-many-pieces-are-moved-on-cluster-change">How many pieces are moved on cluster change?</a></h2>
<p>In computing N holder nodes for a key,
computing the holder node for each (key, index) pair independently
is a local-optimal solution.
In this case, it is guaranteed that only one piece is moved
per key for any one cluster change but occasionally happen to 
place all pieces in one node which lose the redundancy we hope to have:
for (N,K) erasure coding we should be allowed to lose N-K pieces.</p>
<p>So choose N independent holders and let's estimate how many pieces
are moved per cluster change.</p>
<p>Suppose the placement before cluster change is S1,S2,S3,S4 (n=4)
which is computed by consistent manner
(Sorock uses ASURA but you can use consistent-hashing or whatever that functions the same)
and There is an equal possibility of losing each server.
If we remove S2 for example and the next placement is S1,S3,S4,S5 we need to move 3 pieces
(S2-&gt;S3,S3-&gt;S4,S4-&gt;S5). If we remove S4 only one piece is moved.</p>
<p>The average moves will be</p>
<p>\[ \frac{1}{N} \sum_{i=1}^{N-1} i = \frac{N-1}{2} \]</p>
<p>If there are C nodes in the cluster, the possibility of choose either one in N nodes is</p>
<p>\[ \frac{N}{C} \]</p>
<p>then the expectation number of moves per key will be</p>
<p>\[ \frac{N(N-1)}{2C} \]</p>
<p>Because the possibility that one node out of C nodes went down
in a certain period
is proportional to C</p>
<p>\[ pC \]</p>
<p>So the expectation number of moves per key per time will be</p>
<p>\[ \frac{pN(N-1)}{2} \]</p>
<h2><a class="header" href="#how-many-random-numbers-are-need-to-compute-n-holders" id="how-many-random-numbers-are-need-to-compute-n-holders">How many random numbers are need to compute N holders?</a></h2>
<p>Suppose all nodes have the same capacity.
In ASURA, we need 1 random number to choose the first node.
Because we need to choose the second node other than the choosen node,
the expection number for the second choice will be</p>
<p>\[ \frac{C}{C-1} \]</p>
<p>So the expection number to compute the all N holders in general will be </p>
<p>\[ \sum_{i=0}^{N-1} \frac{C}{C-i} = \sum_{i=0}^{N-1} ( 1 + \frac{i}{C-i} ) = N + \sum_{i=0}^{N-1} \frac{i}{C-i} \]</p>
<p>This means when C is large enough (100~) the cost of computing N holders is decreasing to only N (one random number per holder which is super fast). Since the holder computation is frequently executed in the implementation and erasure-coding storage uses a lot of computational resource, the cost should be lower as possible. This is why I choose to use ASURA.</p>
<h2><a class="header" href="#approximation-of-node-failure-possibility" id="approximation-of-node-failure-possibility">Approximation of node failure possibility</a></h2>
<p>Failure rate p during period T is</p>
<p>\[ p = 1 - e^{\frac{-T}{MTBF}} \]</p>
<p>Maclaurin expansion of \( e^x \) is</p>
<p>\[ e^x = 1 + x + \frac{x^2}{2} + \ ... \]</p>
<p>If \(x^2 \ll 1 \), we get an approximation</p>
<p>\[ e^x = 1 + x \]
\[ -x = 1 - e^x \]</p>
<p>If \(T \ll MTBF \)</p>
<p>\[ p = \frac{T}{MTBF} = 1 - e^{\frac{-T}{MTBF}} \]</p>
<h2><a class="header" href="#possibility-of-data-loss" id="possibility-of-data-loss">Possibility of data loss?</a></h2>
<p>In (N,K) erasure coding, a data is splitted into K pieces and add N-K parities.
It is allowed to lose at most N-K pieces out of total N.</p>
<p>So the chance of losing no more than N-K pieces is</p>
<p>\[ P_l(p) = \sum_{i=0}^{N-K} \binom{N}{i} \ p^i \ (1-p)^{N-i} \]</p>
<p>This should be a monotonic function of p
so we can solve this by binary searching.</p>
<p>Now, we can say Sorock will not lose the data in \(P_{SLA} = 0.99999999999\) (so-called Eleven-nine) if
these two conditions are satisfied:</p>
<ol>
<li>We can find p such that \(P_l(p) \ge P_{SLA}\).</li>
<li>We can recover every lost pieces within \(T \le p \times MTBF\).</li>
</ol>
<p>data-loss-calculator is the implementation of this algorithm.
An example of calculation is for (8,4) erasure coding (meaning 4 data chunks and 4 parity chunks)
and MTBF of 1M hours, every piece should be recovered every 2824 hours to
achieve Evelen-nine SLA level.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
